#!/usr/bin/env python3
"""
Stormglass 24æ™‚é–“ç‰ˆ ä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆ + æ—¥æ¬¡æ›´æ–°ï¼ˆäºˆå ±å¯¾å¿œï¼‰

ä½¿ã„æ–¹:
  # åˆå›: å…¨æœŸé–“ã‚’ä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆ2020-01-01 ã€œ 10æ—¥å¾Œï¼‰
  python3 bulk_import_weather.py --full

  # æ—¥æ¬¡: 2æ—¥å‰ã€œ10æ—¥å¾Œã‚’å–å¾—ï¼ˆCloud Schedulerã§1æ—¥1å›ï¼‰
  python3 bulk_import_weather.py

  # ã‚ªãƒ—ã‚·ãƒ§ãƒ³
  python3 bulk_import_weather.py --location ogasawara  # ç‰¹å®šåœ°ç‚¹ã®ã¿
  python3 bulk_import_weather.py --dry-run             # ç¢ºèªã®ã¿
  python3 bulk_import_weather.py --no-notify           # é€šçŸ¥ãªã—

ç’°å¢ƒå¤‰æ•°:
  SUPABASE_URL, SUPABASE_KEY, STORMGLASS_KEY
  TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID
"""

import argparse
import os
import sys
import time
import requests
from datetime import datetime, timezone, timedelta

# ========== è¨­å®šï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼‰ ==========
SUPABASE_URL = os.environ.get("SUPABASE_URL", "")
SUPABASE_KEY = os.environ.get("SUPABASE_KEY", "")
STORMGLASS_KEY = os.environ.get("STORMGLASS_KEY", "")
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "")
TELEGRAM_CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID", "")

STORMGLASS_URL = "https://api.stormglass.io/v2/weather/point"

# å–å¾—ç¯„å›²: 2æ—¥å‰ ã€œ 10æ—¥å¾Œï¼ˆStormglassäºˆå ±ä¸Šé™ï¼‰
PAST_DAYS = 2
FORECAST_DAYS = 10
DEFAULT_START = datetime(2020, 1, 1, tzinfo=timezone.utc)

PARAMS = ['waveHeight', 'wavePeriod', 'waveDirection', 'windWaveHeight', 'windWavePeriod', 'windWaveDirection', 
          'swellHeight', 'swellPeriod', 'swellDirection', 'windSpeed', 'windDirection', 'gust', 
          'currentSpeed', 'currentDirection', 'airTemperature', 'waterTemperature', 
          'cloudCover', 'precipitation', 'humidity', 'pressure', 'visibility', 'seaLevel']

COLUMN_MAP = {
    'waveHeight': 'wave_height', 'wavePeriod': 'wave_period', 'waveDirection': 'wave_direction',
    'windWaveHeight': 'wind_wave_height', 'windWavePeriod': 'wind_wave_period', 'windWaveDirection': 'wind_wave_direction',
    'swellHeight': 'swell_height', 'swellPeriod': 'swell_period', 'swellDirection': 'swell_direction',
    'windSpeed': 'wind_speed', 'windDirection': 'wind_direction', 'gust': 'gust',
    'currentSpeed': 'current_speed', 'currentDirection': 'current_direction',
    'airTemperature': 'air_temperature', 'waterTemperature': 'water_temperature',
    'cloudCover': 'cloud_cover', 'precipitation': 'precipitation', 'humidity': 'humidity',
    'pressure': 'pressure', 'visibility': 'visibility', 'seaLevel': 'sea_level'
}

UTC = timezone.utc
JST = timezone(timedelta(hours=9))

# åœ°ç‚¹ã®çŸ­ç¸®å
LOCATION_SHORT = {
    'okinawa_sesoko': 'ç€¬åº•', 'okinawa_manza': 'ä¸‡åº§', 'kerama': 'æ…¶è‰¯é–“', 'sekisei': 'çŸ³è¥¿',
    'amami': 'å¥„ç¾', 'ogasawara': 'å°ç¬ åŸ', 'hachijojima': 'å…«ä¸ˆå³¶', 'kushimoto': 'ä¸²æœ¬',
    'ishigaki_taketomi': 'ç«¹å¯Œ',
    'maldives_north_male': 'N.Male', 'maldives_south_male': 'S.Male', 
    'maldives_north_ari': 'N.Ari', 'maldives_south_ari': 'S.Ari'
}

# åœ°ç‚¹ã®è¡¨ç¤ºé †
LOCATION_ORDER = ['okinawa_sesoko', 'okinawa_manza', 'kerama', 'sekisei', 'amami',
                  'ogasawara', 'hachijojima', 'kushimoto', 'ishigaki_taketomi', 
                  'maldives_north_male', 'maldives_south_male', 'maldives_north_ari', 'maldives_south_ari']


def check_env():
    """å¿…é ˆç’°å¢ƒå¤‰æ•°ã‚’ãƒã‚§ãƒƒã‚¯"""
    missing = []
    if not SUPABASE_URL:
        missing.append("SUPABASE_URL")
    if not SUPABASE_KEY:
        missing.append("SUPABASE_KEY")
    if not STORMGLASS_KEY:
        missing.append("STORMGLASS_KEY")
    
    if missing:
        print(f"âŒ å¿…é ˆç’°å¢ƒå¤‰æ•°ãŒæœªè¨­å®š: {', '.join(missing)}")
        sys.exit(1)


def send_telegram(message, is_error=False):
    """Telegramé€šçŸ¥ã‚’é€ä¿¡"""
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        print("âš ï¸ Telegramè¨­å®šãªã—ï¼ˆé€šçŸ¥ã‚¹ã‚­ãƒƒãƒ—ï¼‰")
        return False
    
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    try:
        resp = requests.post(url, json={
            "chat_id": TELEGRAM_CHAT_ID,
            "text": message,
            "parse_mode": "HTML"
        }, timeout=10)
        return resp.status_code == 200
    except Exception as e:
        print(f"âš ï¸ Telegramé€ä¿¡å¤±æ•—: {e}")
        return False


def get_locations(filter_name=None):
    """Supabaseã‹ã‚‰åœ°ç‚¹å–å¾—"""
    headers = {"apikey": SUPABASE_KEY, "Authorization": f"Bearer {SUPABASE_KEY}"}
    url = f"{SUPABASE_URL}/rest/v1/locations?active=eq.true&select=name,lat,lng"
    if filter_name:
        url += f"&name=eq.{filter_name}"
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()


def get_latest_datetime(location_name):
    """æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã®UTCæ—¥æ™‚ã‚’å–å¾—"""
    headers = {"apikey": SUPABASE_KEY, "Authorization": f"Bearer {SUPABASE_KEY}"}
    url = f"{SUPABASE_URL}/rest/v1/marine_weather?location=eq.{location_name}&select=datetime&order=datetime.desc&limit=1"
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    data = resp.json()
    if data:
        return datetime.fromisoformat(data[0]['datetime'].replace('Z', '+00:00'))
    return None


def get_latest_weather(location_name):
    """æœ€æ–°ã®æµ·æ³ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—"""
    headers = {"apikey": SUPABASE_KEY, "Authorization": f"Bearer {SUPABASE_KEY}"}
    url = (f"{SUPABASE_URL}/rest/v1/marine_weather?location=eq.{location_name}"
           f"&select=datetime,wave_height,swell_height,wind_speed,wind_direction,water_temperature,air_temperature,cloud_cover,precipitation"
           f"&order=datetime.desc&limit=1")
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    data = resp.json()
    return data[0] if data else None


def fetch_stormglass(lat, lng, start_utc, end_utc, retry=3):
    """Stormglass APIã‹ã‚‰å–å¾—ï¼ˆ10æ—¥ãƒãƒ£ãƒ³ã‚¯ï¼‰"""
    headers = {"Authorization": STORMGLASS_KEY}
    all_hours = []
    chunk_days = 10
    current = start_utc
    
    while current < end_utc:
        chunk_end = min(current + timedelta(days=chunk_days), end_utc)
        params = {
            'lat': lat, 'lng': lng,
            'params': ','.join(PARAMS),
            'start': current.strftime('%Y-%m-%dT%H:%M:%SZ'),
            'end': chunk_end.strftime('%Y-%m-%dT%H:%M:%SZ')
        }
        
        for attempt in range(retry):
            try:
                resp = requests.get(STORMGLASS_URL, params=params, headers=headers, timeout=60)
                resp.raise_for_status()
                all_hours.extend(resp.json().get('hours', []))
                break
            except Exception as e:
                if attempt < retry - 1:
                    print(f"    ãƒªãƒˆãƒ©ã‚¤ä¸­... ({e})")
                    time.sleep(2 ** attempt)
                else:
                    raise
        
        print(f"    {current.strftime('%Y-%m-%d')}...", end=" ", flush=True)
        current = chunk_end
        time.sleep(0.3)
    
    return all_hours


def safe_get(data, key):
    """å€¤å–å¾—ï¼ˆsgã‚½ãƒ¼ã‚¹å„ªå…ˆï¼‰"""
    if key not in data:
        return None
    val = data[key]
    return val.get('sg') if isinstance(val, dict) else val


def transform_to_records(hours, location_name, lat, lng):
    """APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ â†’ DBãƒ¬ã‚³ãƒ¼ãƒ‰ï¼ˆé‡è¤‡æ’é™¤ï¼‰"""
    records = []
    seen = set()
    
    for hour in hours:
        utc_str = hour.get('time')
        if not utc_str:
            continue
        
        if utc_str in seen:
            continue
        seen.add(utc_str)
        
        utc_dt = datetime.fromisoformat(utc_str.replace('Z', '+00:00'))
        
        record = {
            'location': location_name,
            'datetime': utc_dt.strftime('%Y-%m-%dT%H:%M:%S+00:00'),
            'lat': lat,
            'lng': lng
        }
        for api_key, db_col in COLUMN_MAP.items():
            record[db_col] = safe_get(hour, api_key)
        
        records.append(record)
    
    records.sort(key=lambda r: r['datetime'])
    return records


def upload_to_supabase(records, batch_size=500):
    """Supabaseã«upsert"""
    headers = {
        "apikey": SUPABASE_KEY,
        "Authorization": f"Bearer {SUPABASE_KEY}",
        "Content-Type": "application/json",
        "Prefer": "resolution=merge-duplicates"
    }
    
    uploaded = 0
    for i in range(0, len(records), batch_size):
        batch = records[i:i+batch_size]
        resp = requests.post(
            f"{SUPABASE_URL}/rest/v1/marine_weather?on_conflict=location,datetime",
            headers=headers,
            json=batch,
            timeout=60
        )
        if resp.status_code in (200, 201):
            uploaded += len(batch)
        else:
            print(f"    âš ï¸ Error: {resp.status_code} {resp.text[:200]}")
    
    return uploaded


def get_weather_emoji(cloud_cover, precipitation):
    """å¤©å€™ã‚’çµµæ–‡å­—ã§è¡¨ç¾"""
    if precipitation and precipitation > 0:
        return "ğŸŒ§ï¸"
    if cloud_cover is None:
        return "â“"
    if cloud_cover < 30:
        return "â˜€ï¸"
    elif cloud_cover < 70:
        return "â›…"
    else:
        return "â˜ï¸"


def get_wind_direction_arrow(degrees):
    """é¢¨å‘ã‚’çŸ¢å°ã§è¡¨ç¾ï¼ˆé¢¨ãŒå¹ã„ã¦ãã‚‹æ–¹å‘ï¼‰"""
    if degrees is None:
        return ""
    arrows = ["â†“", "â†™", "â†", "â†–", "â†‘", "â†—", "â†’", "â†˜"]
    index = int((degrees + 22.5) / 45) % 8
    return arrows[index]


def get_temp_emoji(water_temp):
    """æ°´æ¸©ã‚’çµµæ–‡å­—ã§è¡¨ç¾ï¼ˆã‚¦ã‚§ãƒƒãƒˆã‚¹ãƒ¼ãƒ„åŸºæº–ï¼‰"""
    if water_temp is None:
        return "â“"
    if water_temp >= 29:
        return "ğŸ”¥"  # 3mm/ãƒ©ãƒƒã‚·ãƒ¥
    elif water_temp >= 26:
        return "ğŸ˜Š"  # 5mmå¿«é©
    elif water_temp >= 23:
        return "ğŸŒŠ"  # 5mm+Î±
    else:
        return "ğŸ¥¶"  # ãƒ‰ãƒ©ã‚¤æ¤œè¨


def get_sea_condition_emoji(wave_height, swell_height, wind_speed):
    """æµ·æ³ã‚’çµµæ–‡å­—ã§è¡¨ç¾"""
    total_wave = (wave_height or 0) + (swell_height or 0)
    wind = wind_speed or 0
    
    if total_wave >= 2.0 or wind >= 12:
        return "ğŸ”´"
    elif total_wave >= 1.0 or wind >= 8:
        return "ğŸŸ¡"
    else:
        return "ğŸŸ¢"


def build_weather_line(location_name, weather_data):
    """1åœ°ç‚¹åˆ†ã®æµ·æ³è¡Œã‚’ç”Ÿæˆ"""
    if not weather_data:
        short = LOCATION_SHORT.get(location_name, location_name)
        return f"âŒ {short}: å–å¾—å¤±æ•—"
    
    short = LOCATION_SHORT.get(location_name, location_name)
    
    weather_emoji = get_weather_emoji(weather_data.get('cloud_cover'), weather_data.get('precipitation'))
    air_temp = weather_data.get('air_temperature') or 0
    water_temp = weather_data.get('water_temperature') or 0
    temp_emoji = get_temp_emoji(water_temp)
    wind_speed = weather_data.get('wind_speed') or 0
    wind_arrow = get_wind_direction_arrow(weather_data.get('wind_direction'))
    wave = weather_data.get('wave_height') or 0
    swell = weather_data.get('swell_height') or 0
    sea_emoji = get_sea_condition_emoji(wave, swell, wind_speed)
    
    return f"{weather_emoji} {short}: {air_temp:.0f}â„ƒ/{water_temp:.0f}â„ƒ{temp_emoji} é¢¨{wind_speed:.0f}m/s{wind_arrow} æ³¢{wave:.1f}m ã†ã­ã‚Š{swell:.1f}m {sea_emoji}"


def build_telegram_message(weather_by_location, total_count, elapsed, errors, success_count, total_locations):
    """Telegramé€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ"""
    # æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã®æ—¥æ™‚ã‚’å–å¾—
    sample_dt = None
    for loc in LOCATION_ORDER:
        w = weather_by_location.get(loc)
        if w and w.get('datetime'):
            sample_dt = datetime.fromisoformat(w['datetime'].replace('Z', '+00:00'))
            break
    
    if sample_dt:
        utc_str = sample_dt.strftime('%m/%d %H:%M UTC')
        jst_dt = sample_dt.astimezone(JST)
        jst_str = jst_dt.strftime('%m/%d %H:%M JST')
        dt_display = f"{utc_str} / {jst_str}"
    else:
        dt_display = ""
    
    lines = [f"ğŸŒŠ æµ·æ³é€Ÿå ± ({dt_display})", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"]
    
    # å„åœ°ç‚¹ã®æµ·æ³
    for loc in LOCATION_ORDER:
        if loc in weather_by_location:
            lines.append(build_weather_line(loc, weather_by_location[loc]))
    
    lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
    
    # å–å¾—çµæœ
    if errors:
        lines.append(f"âš ï¸ {total_count}ä»¶å–å¾— ({success_count}/{total_locations}åœ°ç‚¹æˆåŠŸ)")
    elif total_count == 0:
        lines.append(f"âœ… 0ä»¶å–å¾—ï¼ˆå…¨åœ°ç‚¹æœ€æ–°ï¼‰")
    else:
        lines.append(f"âœ… {total_count}ä»¶å–å¾— ({elapsed:.0f}ç§’)")
    
    lines.append("ğŸ”¥29â„ƒâ†‘ ğŸ˜Š26-28â„ƒ ğŸŒŠ23-25â„ƒ ğŸ¥¶22â„ƒâ†“ ï½œ ğŸŸ¢è‰¯å¥½ ğŸŸ¡æ³¨æ„ ğŸ”´è’ã‚Œ")
    
    return "\n".join(lines)




# ========== Cloud Functions ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ ==========
try:
    import functions_framework
    
    @functions_framework.http
    def update_marine_weather(request):
        """Cloud Functions HTTPãƒˆãƒªã‚¬ãƒ¼ï¼ˆCloud Schedulerç”¨ï¼‰"""
        import json
        
        try:
            # ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯
            check_env()
            
            start_time = time.time()
            now_utc = datetime.now(UTC)
            default_start_utc = now_utc - timedelta(days=PAST_DAYS)
            end_utc = now_utc + timedelta(days=FORECAST_DAYS)
            
            locations = get_locations()
            if not locations:
                return json.dumps({"error": "No locations found"}), 500
            
            results = []
            errors = []
            total = 0
            
            for loc in locations:
                name = loc['name']
                try:
                    hours = fetch_stormglass(loc['lat'], loc['lng'], default_start_utc, end_utc)
                    records = transform_to_records(hours, name, loc['lat'], loc['lng'])
                    uploaded = upload_to_supabase(records)
                    total += uploaded
                    results.append({'name': name, 'count': uploaded, 'status': 'ok'})
                except Exception as e:
                    results.append({'name': name, 'count': 0, 'status': 'error', 'error': str(e)})
                    errors.append({'name': name, 'error': str(e)})
            
            elapsed = time.time() - start_time
            
            # Telegramé€šçŸ¥
            weather_by_location = {}
            for loc in locations:
                weather_by_location[loc['name']] = get_latest_weather(loc['name'])
            
            success_count = len(locations) - len(errors)
            msg = build_telegram_message(weather_by_location, total, elapsed, errors, success_count, len(locations))
            send_telegram(msg, is_error=bool(errors))
            
            return json.dumps({
                "status": "success",
                "total_records": total,
                "locations": len(locations),
                "errors": len(errors),
                "elapsed_sec": round(elapsed, 1)
            }), 200
            
        except Exception as e:
            return json.dumps({"error": str(e)}), 500

except ImportError:
    pass  # ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œæ™‚ã¯ã‚¹ã‚­ãƒƒãƒ—

def main():
    parser = argparse.ArgumentParser(description='Stormglass 24æ™‚é–“ç‰ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆäºˆå ±å¯¾å¿œï¼‰')
    parser.add_argument('--location', type=str, help='ç‰¹å®šåœ°ç‚¹ã®ã¿')
    parser.add_argument('--full', action='store_true', help='å…¨æœŸé–“ä¸€æ‹¬ï¼ˆ2020ã€œ10æ—¥å¾Œï¼‰')
    parser.add_argument('--dry-run', action='store_true', help='ç¢ºèªã®ã¿')
    parser.add_argument('--no-notify', action='store_true', help='é€šçŸ¥ãªã—')
    args = parser.parse_args()
    
    check_env()
    
    start_time = time.time()
    
    # å–å¾—ç¯„å›²: 2æ—¥å‰ ã€œ 10æ—¥å¾Œ
    now_utc = datetime.now(UTC)
    default_start_utc = now_utc - timedelta(days=PAST_DAYS)
    end_utc = now_utc + timedelta(days=FORECAST_DAYS)
    
    print("=" * 50)
    print("Stormglass 24æ™‚é–“ç‰ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆäºˆå ±å¯¾å¿œï¼‰")
    print("=" * 50)
    print(f"ğŸ“… ç¾åœ¨: {now_utc.strftime('%Y-%m-%d %H:%M')} (UTC)")
    print(f"ğŸ“… å–å¾—ç¯„å›²: {default_start_utc.strftime('%Y-%m-%d')} ã€œ {end_utc.strftime('%Y-%m-%d')} ({PAST_DAYS}æ—¥å‰ã€œ{FORECAST_DAYS}æ—¥å¾Œ)")
    print(f"ğŸ• ãƒ¢ãƒ¼ãƒ‰: {'å…¨æœŸé–“ä¸€æ‹¬' if args.full else 'æ—¥æ¬¡æ›´æ–°'}")
    print()
    
    locations = get_locations(args.location)
    if not locations:
        print("âŒ å¯¾è±¡åœ°ç‚¹ãŒã‚ã‚Šã¾ã›ã‚“")
        return
    
    print(f"ğŸ“ å¯¾è±¡åœ°ç‚¹: {len(locations)}ç®‡æ‰€")
    
    location_ranges = []
    for loc in locations:
        name = loc['name']
        
        if args.full:
            start_utc = DEFAULT_START
        else:
            # æ—¥æ¬¡æ›´æ–°: å¸¸ã«2æ—¥å‰ã€œ10æ—¥å¾Œã‚’å–å¾—
            start_utc = default_start_utc
        
        hours_to_fetch = int((end_utc - start_utc).total_seconds() / 3600)
        requests_estimate = max(1, (hours_to_fetch // 240) + 1)
        
        location_ranges.append({
            'name': name, 'lat': loc['lat'], 'lng': loc['lng'],
            'start_utc': start_utc, 'end_utc': end_utc,
            'hours': hours_to_fetch, 'requests': requests_estimate
        })
        
        print(f"   - {name}: {start_utc.strftime('%m/%d')} ã€œ {end_utc.strftime('%m/%d')} ({hours_to_fetch}h, {requests_estimate}req)")
    
    total_requests = sum(lr['requests'] for lr in location_ranges)
    print(f"\nğŸ“Š æ¨å®šAPIãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°: {total_requests}")
    print()
    
    if args.dry_run:
        print("ğŸ” dry-run: å®Ÿè¡Œã—ã¾ã›ã‚“")
        return
    
    # å¯¾è©±ãƒ¢ãƒ¼ãƒ‰ç¢ºèª
    if location_ranges and os.isatty(0):
        input("Enter ã§é–‹å§‹...")
        print()
    
    # å®Ÿè¡Œ
    results = []
    errors = []
    total = 0
    
    for loc in location_ranges:
        name = loc['name']
        print(f"ğŸŒŠ {name}...")
        
        try:
            hours = fetch_stormglass(loc['lat'], loc['lng'], loc['start_utc'], loc['end_utc'])
            print(f"\n   API: {len(hours)} æ™‚é–“")
            
            records = transform_to_records(hours, name, loc['lat'], loc['lng'])
            print(f"   å¤‰æ›: {len(records)} ãƒ¬ã‚³ãƒ¼ãƒ‰")
            
            uploaded = upload_to_supabase(records)
            print(f"   âœ… {uploaded} ä»¶ upsert")
            total += uploaded
            
            results.append({'name': name, 'count': uploaded, 'status': 'ok'})
        except Exception as e:
            print(f"   âŒ {e}")
            results.append({'name': name, 'count': 0, 'status': 'error', 'error': str(e)})
            errors.append({'name': name, 'error': str(e)})
        print()
    
    elapsed = time.time() - start_time
    
    print("=" * 50)
    print(f"âœ… å®Œäº†: åˆè¨ˆ {total} ä»¶ ({elapsed:.1f}ç§’)")
    print("=" * 50)
    
    # Telegramé€šçŸ¥
    if not args.no_notify:
        # æœ€æ–°ã®æµ·æ³ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        weather_by_location = {}
        all_locations = get_locations()
        for loc in all_locations:
            weather_by_location[loc['name']] = get_latest_weather(loc['name'])
        
        success_count = len(all_locations) - len(errors)
        msg = build_telegram_message(weather_by_location, total, elapsed, errors, success_count, len(all_locations))
        send_telegram(msg, is_error=bool(errors))


if __name__ == "__main__":
    main()
